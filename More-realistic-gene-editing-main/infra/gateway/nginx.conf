worker_processes 1;

events { worker_connections 1024; }

http {
    sendfile on;

    server {
        listen 80;
        server_name localhost;

        # Redirect all HTTP traffic to HTTPS
        return 301 https://$host$request_uri;
    }

    server {
        listen 443 ssl;
        server_name localhost;

        # Self-signed certs for local dev. Replace with real certs in prod.
        ssl_certificate /usr/local/nginx/conf/self-signed.crt;
        ssl_certificate_key /usr/local/nginx/conf/self-signed.key;

        # TLS 1.3 with PQC-hybrid preferred group
        ssl_protocols TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256';
        ssl_ecdh_curve X25519:secp384r1;
        # Prefer the PQC-hybrid group, with classic as fallback
        # This requires OpenSSL 3.2+ with liboqs. The Dockerfile provides this.
        ssl_groups X25519Kyber768;

        # Security Headers
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Content-Type-Options nosniff always;
        add_header X-Frame-Options SAMEORIGIN always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self'; connect-src 'self' wss://$host;" always;

        location / {
            proxy_pass http://host.docker.internal:3000; # Assuming web dev server runs on 3000
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /api/auth/ {
            proxy_pass http://auth:8081;
        }

        location /api/kms/ {
            proxy_pass http://kms:8082;
        }

        location / {
            # LiveKit WebSocket Signaling
            proxy_pass http://livekit:7880;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_set_header Host $host;
        }
    }
}
